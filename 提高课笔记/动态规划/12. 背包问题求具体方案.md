# 12. 背包问题求具体方案

[参考博客](https://www.acwing.com/solution/content/2687/)

我感觉这道题从不同的角度学习了一遍 01 背包问题



分析过程：

因为要求选择的物品序号组成的序列字典序最小，于是我们需要从前开始考虑

假设最优解可以选第一个物品，那我们就必选它；假如不能，那我们就必不选；假如选不选都可以，那当然还是要要选。

而在选择判断之前，我们需要用到后面的状态，也就是“在第二个物品到第n个物品中选”对应的最优解

这样我们发现，判断选不选第`i`个物品，要结合后面的情况来判断。

所以定义$f(i,j)$为从第$i$个元素到最后一个元素总容量为$j$的最优解

按照含义，相应的状态转移方程也会发生变化：

$f(i, j) = max(f(i + 1, j), f(i + 1, j - v[i]) + w[i])$

代码上，也要进行相应的变化



```cpp
#include<iostream>
using namespace std;

const int N = 1010;

int f[N][N];    // 为了方便求方案数，定义f[i][j]表示在i到最后一个物品中选，体积不超过j的最大价值
                // f[i][j] = max(f[i + 1][j], f[i + 1][j - v[i]] + w[i])
int v[N], w[N]; // 因为这题要倒着做，所以要先把输入保存
int n, m;

int main(void){
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = n; i >= 1; i -- ){		// 从后往前
        for (int j = 0; j <= m; j ++ ){
            f[i][j] = f[i + 1][j];      // 首先是不选
            if (j >= v[i])  f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);  // 然后尝试选
        }
    } 
    // 此时 f[1][m] 就对应了最大价值
    // 我们通过值的比较来判断是否选某个元素，另外注意
    // 如果f[i][j]仅等于f[i + 1][j]，说明第 i 个物品只能不选
    // 如果 f[i][j] 仅等于 f[i + 1][j - v[i]] + w[i]， 只能选
    // 如果都相等，还是选

    int j = m; 
    for (int i = 1; i <= n; i ++ ){
        if (j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i]){
            cout << i << " ";
            j -= v[i];
        }
    }
    return 0;
}
```

